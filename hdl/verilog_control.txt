/**
 * control_unit.v - Unidad de control basada en FSM
 * 
 * Lee instrucciones de una ROM y genera señales de control
 * La ROM contiene el "microcódigo" aprendido por el agente RL
 */

module control_unit #(
    parameter NUM_STATES = 16,
    parameter ROM_FILE = "rom_data.mem"
)(
    input wire clk,
    input wire rst_n,
    input wire start,           // Señal para iniciar operación
    
    // Flags del datapath
    input wire flag_z,
    input wire flag_lsb,
    input wire flag_c,
    
    // Señales de control hacia el datapath
    output reg [2:0] alu_op,
    output reg [1:0] alu_src_a,
    output reg [1:0] alu_src_b,
    output reg [2:0] shift_op,
    output reg [1:0] shift_target,
    output reg write_p,
    output reg write_temp,
    output reg write_b,
    output reg load_inputs,
    
    // Estado y señales de estado
    output reg [3:0] current_state,
    output reg done
);

    // ROM de instrucciones (23 bits por instrucción)
    reg [22:0] rom [0:NUM_STATES-1];
    
    // Registro de instrucción actual
    reg [22:0] instruction;
    
    // Próximo estado
    wire [3:0] next_state;
    
    // Decodificación de instrucción
    // Formato: [next_state(4) | write_b | write_temp | write_p | 
    //           shift_target(2) | shift_op(3) | alu_src_b(2) | 
    //           alu_src_a(2) | alu_op(3)]
    
    assign next_state = instruction[18:15];
    
    // Estados especiales
    localparam STATE_IDLE = 4'd0;
    localparam STATE_HALT = 4'd15;
    
    // Inicializar ROM desde archivo
    initial begin
        $readmemh(ROM_FILE, rom);
    end
    
    //===========================================
    // Máquina de estados
    //===========================================
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= STATE_IDLE;
            done <= 1'b0;
            load_inputs <= 1'b0;
        end else begin
            if (current_state == STATE_IDLE) begin
                if (start) begin
                    current_state <= 4'd1;  // Ir al primer estado de ejecución
                    load_inputs <= 1'b1;
                    done <= 1'b0;
                end
            end else if (current_state == STATE_HALT) begin
                done <= 1'b1;
                load_inputs <= 1'b0;
            end else begin
                current_state <= next_state;
                load_inputs <= 1'b0;
                
                // Si llegamos a HALT, marcar como terminado
                if (next_state == STATE_HALT) begin
                    done <= 1'b1;
                end
            end
        end
    end
    
    //===========================================
    // Lectura de ROM y decodificación
    //===========================================
    
    always @(*) begin
        // Leer instrucción de la ROM
        instruction = rom[current_state];
        
        // Decodificar señales de control
        alu_op = instruction[2:0];
        alu_src_a = instruction[4:3];
        alu_src_b = instruction[6:5];
        shift_op = instruction[9:7];
        shift_target = instruction[11:10];
        write_p = instruction[12];
        write_temp = instruction[13];
        write_b = instruction[14];
        
        // En estado IDLE o HALT, no hacer nada
        if (current_state == STATE_IDLE || current_state == STATE_HALT) begin
            alu_op = 3'b000;
            alu_src_a = 2'b00;
            alu_src_b = 2'b00;
            shift_op = 3'b000;
            shift_target = 2'b00;
            write_p = 1'b0;
            write_temp = 1'b0;
            write_b = 1'b0;
        end
    end

endmodule


/**
 * control_unit_conditional.v - Variante con saltos condicionales
 * 
 * Esta versión permite que los saltos de estado dependan de los flags
 * Útil para algoritmos más complejos
 */
module control_unit_conditional #(
    parameter NUM_STATES = 16,
    parameter ROM_FILE = "rom_data.mem"
)(
    input wire clk,
    input wire rst_n,
    input wire start,
    
    // Flags
    input wire flag_z,
    input wire flag_lsb,
    input wire flag_c,
    
    // Señales de control
    output reg [2:0] alu_op,
    output reg [1:0] alu_src_a,
    output reg [1:0] alu_src_b,
    output reg [2:0] shift_op,
    output reg [1:0] shift_target,
    output reg write_p,
    output reg write_temp,
    output reg write_b,
    output reg load_inputs,
    
    output reg [3:0] current_state,
    output reg done
);

    // ROM expandida: para cada estado, dos instrucciones
    // Una si flag_lsb=0, otra si flag_lsb=1
    reg [22:0] rom_even [0:NUM_STATES-1];  // Para cuando flag_lsb=0
    reg [22:0] rom_odd [0:NUM_STATES-1];   // Para cuando flag_lsb=1
    
    reg [22:0] instruction;
    wire [3:0] next_state;
    
    assign next_state = instruction[18:15];
    
    localparam STATE_IDLE = 4'd0;
    localparam STATE_HALT = 4'd15;
    
    initial begin
        // Cargar ambas ROMs
        $readmemh(ROM_FILE, rom_even);
        $readmemh({ROM_FILE, ".odd"}, rom_odd);
    end
    
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            current_state <= STATE_IDLE;
            done <= 1'b0;
            load_inputs <= 1'b0;
        end else begin
            if (current_state == STATE_IDLE) begin
                if (start) begin
                    current_state <= 4'd1;
                    load_inputs <= 1'b1;
                    done <= 1'b0;
                end
            end else if (current_state == STATE_HALT) begin
                done <= 1'b1;
                load_inputs <= 1'b0;
            end else begin
                current_state <= next_state;
                load_inputs <= 1'b0;
                
                if (next_state == STATE_HALT) begin
                    done <= 1'b1;
                end
            end
        end
    end
    
    always @(*) begin
        // Seleccionar instrucción según flag_lsb
        if (flag_lsb)
            instruction = rom_odd[current_state];
        else
            instruction = rom_even[current_state];
        
        // Decodificar
        alu_op = instruction[2:0];
        alu_src_a = instruction[4:3];
        alu_src_b = instruction[6:5];
        shift_op = instruction[9:7];
        shift_target = instruction[11:10];
        write_p = instruction[12];
        write_temp = instruction[13];
        write_b = instruction[14];
        
        if (current_state == STATE_IDLE || current_state == STATE_HALT) begin
            alu_op = 3'b000;
            alu_src_a = 2'b00;
            alu_src_b = 2'b00;
            shift_op = 3'b000;
            shift_target = 2'b00;
            write_p = 1'b0;
            write_temp = 1'b0;
            write_b = 1'b0;
        end
    end

endmodule
