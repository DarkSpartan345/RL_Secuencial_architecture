/**
 * test_bench.v - Testbench para verificar el multiplicador
 * 
 * Prueba múltiples casos y compara con resultados esperados
 */

`timescale 1ns/1ps

module multiplier_tb;

    // Parámetros
    parameter BIT_WIDTH = 8;
    parameter NUM_STATES = 16;
    parameter CLK_PERIOD = 10; // 100 MHz
    parameter MAX_CYCLES = 64;
    
    // Señales del DUT
    reg clk;
    reg rst_n;
    reg [BIT_WIDTH-1:0] multiplicand;
    reg [BIT_WIDTH-1:0] multiplier;
    reg start;
    
    wire [BIT_WIDTH-1:0] product;
    wire done;
    wire [3:0] current_state;
    wire [BIT_WIDTH-1:0] reg_a_debug;
    wire [BIT_WIDTH-1:0] reg_b_debug;
    wire flag_z_debug;
    wire flag_lsb_debug;
    wire flag_c_debug;
    
    // Variables de test
    integer test_num;
    integer errors;
    integer cycle_count;
    reg [2*BIT_WIDTH-1:0] expected_product;
    
    //===========================================
    // Instanciar DUT
    //===========================================
    
    multiplier_top #(
        .BIT_WIDTH(BIT_WIDTH),
        .NUM_STATES(NUM_STATES)
    ) dut (
        .clk(clk),
        .rst_n(rst_n),
        .multiplicand(multiplicand),
        .multiplier(multiplier),
        .start(start),
        .product(product),
        .done(done),
        .current_state(current_state),
        .reg_a_debug(reg_a_debug),
        .reg_b_debug(reg_b_debug),
        .flag_z_debug(flag_z_debug),
        .flag_lsb_debug(flag_lsb_debug),
        .flag_c_debug(flag_c_debug)
    );
    
    //===========================================
    // Generación de reloj
    //===========================================
    
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    //===========================================
    // Task para ejecutar una multiplicación
    //===========================================
    
    task run_multiplication;
        input [BIT_WIDTH-1:0] a;
        input [BIT_WIDTH-1:0] b;
        begin
            multiplicand = a;
            multiplier = b;
            expected_product = a * b;
            cycle_count = 0;
            
            $display("Test #%0d: %0d * %0d = %0d (expected)", 
                     test_num, a, b, expected_product[BIT_WIDTH-1:0]);
            
            // Pulso de start
            @(posedge clk);
            start = 1'b1;
            @(posedge clk);
            start = 1'b0;
            
            // Esperar hasta done o timeout
            while (!done && cycle_count < MAX_CYCLES) begin
                @(posedge clk);
                cycle_count = cycle_count + 1;
                
                // Debug trace (comentar si no se necesita)
                /*$display("  Cycle %0d: State=%0d A=%0d B=%0d P=%0d Z=%b LSB=%b C=%b",
                         cycle_count, current_state, 
                         reg_a_debug, reg_b_debug, product,
                         flag_z_debug, flag_lsb_debug, flag_c_debug);*/
            end
            
            // Verificar resultado
            if (!done) begin
                $display("  ERROR: Timeout after %0d cycles", MAX_CYCLES);
                errors = errors + 1;
            end else if (product != expected_product[BIT_WIDTH-1:0]) begin
                $display("  ERROR: Got %0d, expected %0d (cycles: %0d)", 
                         product, expected_product[BIT_WIDTH-1:0], cycle_count);
                errors = errors + 1;
            end else begin
                $display("  PASS: Result=%0d (cycles: %0d)", product, cycle_count);
            end
            
            test_num = test_num + 1;
            
            // Esperar un ciclo entre tests
            repeat(3) @(posedge clk);
        end
    endtask
    
    //===========================================
    // Estímulo de prueba
    //===========================================
    
    initial begin
        // Inicializar
        rst_n = 0;
        start = 0;
        multiplicand = 0;
        multiplier = 0;
        test_num = 1;
        errors = 0;
        
        // Generar archivo VCD para visualización
        $dumpfile("multiplier_tb.vcd");
        $dumpvars(0, multiplier_tb);
        
        $display("========================================");
        $display("Iniciando testbench del multiplicador");
        $display("Bit width: %0d", BIT_WIDTH);
        $display("========================================");
        
        // Reset
        repeat(5) @(posedge clk);
        rst_n = 1;
        repeat(2) @(posedge clk);
        
        //===========================================
        // Casos de prueba
        //===========================================
        
        // Casos básicos
        $display("\n--- Casos básicos ---");
        run_multiplication(0, 0);       // 0 * 0
        run_multiplication(1, 1);       // 1 * 1
        run_multiplication(0, 5);       // 0 * 5
        run_multiplication(5, 0);       // 5 * 0
        run_multiplication(1, 10);      // 1 * 10
        run_multiplication(10, 1);      // 10 * 1
        
        // Potencias de 2
        $display("\n--- Potencias de 2 ---");
        run_multiplication(2, 3);       // 2 * 3
        run_multiplication(4, 5);       // 4 * 5
        run_multiplication(8, 7);       // 8 * 7
        run_multiplication(16, 3);      // 16 * 3
        
        // Números pequeños
        $display("\n--- Números pequeños ---");
        run_multiplication(3, 5);       // 3 * 5
        run_multiplication(7, 8);       // 7 * 8
        run_multiplication(6, 9);       // 6 * 9
        run_multiplication(12, 13);     // 12 * 13
        
        // Números medianos
        $display("\n--- Números medianos ---");
        run_multiplication(25, 6);      // 25 * 6
        run_multiplication(30, 7);      // 30 * 7
        run_multiplication(50, 4);      // 50 * 4
        
        // Números grandes (con overflow esperado)
        $display("\n--- Números grandes (con truncamiento) ---");
        run_multiplication(100, 3);     // 100 * 3 = 300 -> truncado a 8 bits
        run_multiplication(150, 2);     // 150 * 2 = 300 -> truncado
        run_multiplication(200, 200);   // Overflow significativo
        run_multiplication(255, 255);   // Máximo * máximo
        
        // Casos aleatorios
        $display("\n--- Casos aleatorios ---");
        repeat(20) begin
            run_multiplication($random % (2**BIT_WIDTH), 
                             $random % (2**BIT_WIDTH));
        end
        
        // Casos exhaustivos (para bit_width pequeño)
        if (BIT_WIDTH <= 4) begin
            $display("\n--- Prueba exhaustiva ---");
            for (integer i = 0; i < 2**BIT_WIDTH; i = i + 1) begin
                for (integer j = 0; j < 2**BIT_WIDTH; j = j + 1) begin
                    run_multiplication(i, j);
                end
            end
        end
        
        //===========================================
        // Resumen final
        //===========================================
        
        $display("\n========================================");
        $display("Testbench completado");
        $display("Total tests: %0d", test_num - 1);
        $display("Errores: %0d", errors);
        if (errors == 0) begin
            $display("RESULTADO: TODOS LOS TESTS PASARON! ✓");
        end else begin
            $display("RESULTADO: %0d TESTS FALLARON ✗", errors);
        end
        $display("========================================\n");
        
        $finish;
    end
    
    //===========================================
    // Watchdog timer
    //===========================================
    
    initial begin
        #(CLK_PERIOD * MAX_CYCLES * 100); // Timeout global
        $display("ERROR: Timeout global del testbench");
        $finish;
    end

endmodule


/**
 * datapath_unit_test.v - Pruebas unitarias del datapath
 */
module datapath_unit_test;
    
    parameter BIT_WIDTH = 8;
    parameter CLK_PERIOD = 10;
    
    reg clk, rst_n;
    reg [BIT_WIDTH-1:0] data_a_in, data_b_in;
    reg load_inputs;
    reg [2:0] alu_op;
    reg [1:0] alu_src_a, alu_src_b;
    reg [2:0] shift_op;
    reg [1:0] shift_target;
    reg write_p, write_temp, write_b;
    
    wire [BIT_WIDTH-1:0] reg_a_out, reg_b_out, reg_p_out, reg_temp_out;
    wire flag_z, flag_lsb, flag_c;
    
    datapath #(.BIT_WIDTH(BIT_WIDTH)) dut (.*);
    
    initial begin
        clk = 0;
        forever #(CLK_PERIOD/2) clk = ~clk;
    end
    
    initial begin
        $display("=== Datapath Unit Tests ===");
        
        // Reset
        rst_n = 0;
        load_inputs = 0;
        {alu_op, alu_src_a, alu_src_b, shift_op, shift_target} = 0;
        {write_p, write_temp, write_b} = 0;
        repeat(2) @(posedge clk);
        rst_n = 1;
        
        // Test 1: Load inputs
        $display("Test 1: Load inputs");
        @(posedge clk);
        data_a_in = 42;
        data_b_in = 13;
        load_inputs = 1;
        @(posedge clk);
        load_inputs = 0;
        @(posedge clk);
        assert(reg_a_out == 42 && reg_b_out == 13) 
            else $error("Load failed");
        
        // Test 2: ADD operation
        $display("Test 2: ADD operation");
        @(posedge clk);
        alu_op = 3'b000;  // ADD
        alu_src_a = 2'b00;  // A
        alu_src_b = 2'b00;  // B
        write_p = 1;
        @(posedge clk);
        write_p = 0;
        @(posedge clk);
        assert(reg_p_out == 55) else $error("ADD failed: %0d", reg_p_out);
        
        // Test 3: Shift left
        $display("Test 3: Shift operations");
        @(posedge clk);
        shift_op = 3'b001;  // SHL
        shift_target = 2'b11;  // P
        @(posedge clk);
        shift_op = 3'b000;
        @(posedge clk);
        assert(reg_p_out == 110) else $error("SHL failed: %0d", reg_p_out);
        
        $display("=== All unit tests passed ===");
        $finish;
    end

endmodule
