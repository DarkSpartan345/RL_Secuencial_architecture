/**
 * top.v - Módulo top-level del multiplicador aprendido
 * 
 * Integra el datapath y la unidad de control
 * Este es el módulo que se sintetiza en la FPGA
 */

module multiplier_top #(
    parameter BIT_WIDTH = 8,
    parameter NUM_STATES = 16,
    parameter ROM_FILE = "rom_data.mem"
)(
    input wire clk,
    input wire rst_n,
    
    // Interface de entrada
    input wire [BIT_WIDTH-1:0] multiplicand,
    input wire [BIT_WIDTH-1:0] multiplier,
    input wire start,
    
    // Interface de salida
    output wire [BIT_WIDTH-1:0] product,
    output wire done,
    
    // Debug outputs (opcional)
    output wire [3:0] current_state,
    output wire [BIT_WIDTH-1:0] reg_a_debug,
    output wire [BIT_WIDTH-1:0] reg_b_debug,
    output wire flag_z_debug,
    output wire flag_lsb_debug,
    output wire flag_c_debug
);

    // Señales internas de control
    wire [2:0] alu_op;
    wire [1:0] alu_src_a;
    wire [1:0] alu_src_b;
    wire [2:0] shift_op;
    wire [1:0] shift_target;
    wire write_p;
    wire write_temp;
    wire write_b;
    wire load_inputs;
    
    // Flags del datapath
    wire flag_z;
    wire flag_lsb;
    wire flag_c;
    
    // Registros del datapath
    wire [BIT_WIDTH-1:0] reg_a;
    wire [BIT_WIDTH-1:0] reg_b;
    wire [BIT_WIDTH-1:0] reg_p;
    wire [BIT_WIDTH-1:0] reg_temp;
    
    //===========================================
    // Instanciar Datapath
    //===========================================
    
    datapath #(
        .BIT_WIDTH(BIT_WIDTH)
    ) datapath_inst (
        .clk(clk),
        .rst_n(rst_n),
        
        // Entradas
        .data_a_in(multiplicand),
        .data_b_in(multiplier),
        .load_inputs(load_inputs),
        
        // Señales de control
        .alu_op(alu_op),
        .alu_src_a(alu_src_a),
        .alu_src_b(alu_src_b),
        .shift_op(shift_op),
        .shift_target(shift_target),
        .write_p(write_p),
        .write_temp(write_temp),
        .write_b(write_b),
        
        // Salidas
        .reg_a_out(reg_a),
        .reg_b_out(reg_b),
        .reg_p_out(reg_p),
        .reg_temp_out(reg_temp),
        
        // Flags
        .flag_z(flag_z),
        .flag_lsb(flag_lsb),
        .flag_c(flag_c)
    );
    
    //===========================================
    // Instanciar Unidad de Control
    //===========================================
    
    control_unit #(
        .NUM_STATES(NUM_STATES),
        .ROM_FILE(ROM_FILE)
    ) control_inst (
        .clk(clk),
        .rst_n(rst_n),
        .start(start),
        
        // Flags
        .flag_z(flag_z),
        .flag_lsb(flag_lsb),
        .flag_c(flag_c),
        
        // Señales de control
        .alu_op(alu_op),
        .alu_src_a(alu_src_a),
        .alu_src_b(alu_src_b),
        .shift_op(shift_op),
        .shift_target(shift_target),
        .write_p(write_p),
        .write_temp(write_temp),
        .write_b(write_b),
        .load_inputs(load_inputs),
        
        // Estado
        .current_state(current_state),
        .done(done)
    );
    
    //===========================================
    // Asignaciones de salida
    //===========================================
    
    assign product = reg_p;
    
    // Debug outputs
    assign reg_a_debug = reg_a;
    assign reg_b_debug = reg_b;
    assign flag_z_debug = flag_z;
    assign flag_lsb_debug = flag_lsb;
    assign flag_c_debug = flag_c;

endmodule


/**
 * multiplier_wrapper.v - Wrapper con interface simplificada
 * 
 * Para facilitar la integración en sistemas más grandes
 */
module multiplier_wrapper #(
    parameter BIT_WIDTH = 8
)(
    input wire clk,
    input wire rst_n,
    
    // Simple handshake interface
    input wire [BIT_WIDTH-1:0] a,
    input wire [BIT_WIDTH-1:0] b,
    input wire valid_in,
    output reg ready_out,
    
    output reg [BIT_WIDTH-1:0] product_out,
    output reg valid_out
);

    wire [BIT_WIDTH-1:0] product;
    wire done;
    reg start;
    
    // Estados del wrapper
    localparam IDLE = 2'b00;
    localparam BUSY = 2'b01;
    localparam VALID = 2'b10;
    
    reg [1:0] state;
    
    // Instanciar multiplicador
    multiplier_top #(
        .BIT_WIDTH(BIT_WIDTH)
    ) mult_inst (
        .clk(clk),
        .rst_n(rst_n),
        .multiplicand(a),
        .multiplier(b),
        .start(start),
        .product(product),
        .done(done),
        .current_state(),
        .reg_a_debug(),
        .reg_b_debug(),
        .flag_z_debug(),
        .flag_lsb_debug(),
        .flag_c_debug()
    );
    
    // Máquina de estados del wrapper
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state <= IDLE;
            ready_out <= 1'b1;
            valid_out <= 1'b0;
            start <= 1'b0;
            product_out <= {BIT_WIDTH{1'b0}};
        end else begin
            case (state)
                IDLE: begin
                    ready_out <= 1'b1;
                    valid_out <= 1'b0;
                    start <= 1'b0;
                    
                    if (valid_in) begin
                        start <= 1'b1;
                        state <= BUSY;
                        ready_out <= 1'b0;
                    end
                end
                
                BUSY: begin
                    start <= 1'b0;
                    if (done) begin
                        product_out <= product;
                        valid_out <= 1'b1;
                        state <= VALID;
                    end
                end
                
                VALID: begin
                    valid_out <= 1'b0;
                    state <= IDLE;
                end
                
                default: state <= IDLE;
            endcase
        end
    end

endmodule
